generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider      = "mysql"
  url           = env("DATABASE_URL")
  relationMode  = "prisma"
}

// Surveys

model Survey {
  id              String          @id @default(cuid())
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  name            String          @db.VarChar(255)
  slug            String          @db.VarChar(255)
  description     String?         @db.Text

  userId          String
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  questions       Question[]
  participations  Participation[]

  @@unique([slug])
  @@index([userId])
}

enum QuestionType {
  BOOLEAN
  INTEGER
  DECIMAL
  STRING
}

model Question {
  id            String            @id @default(cuid())
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  name          String            @db.VarChar(255)
  type          QuestionType
  minCount      Int?
  maxCount      Int?
  minLength     Int?
  maxLength     Int?
  minValue      Int?
  maxValue      Int?
  stepValue     Int?
  decimalPlaces Int?
  allowCustom   Boolean           @default(false)

  surveyId      String
  survey        Survey            @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  choices       QuestionChoice[]
  answers       Answer[]

  @@index([surveyId])
}

model QuestionChoice {
  id          String    @id @default(cuid())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  value       String?   @db.Text
  label       String?   @db.Text

  questionId  String
  question    Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@index([questionId])
}

model Participation {
  id          String    @id @default(cuid())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  ipHash      String    @db.Char(128)

  surveyId    String
  survey      Survey    @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  userId      String?
  user        User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  answers     Answer[]

  @@index([surveyId])
  @@index([userId])
}

model Answer {
  id              String        @id @default(cuid())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  valueIndex      Int
  value           String        @db.Text

  participationId String
  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade)
  questionId      String
  question        Question      @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@index([participationId])
  @@index([questionId])
}

// NextAuth.js

// For some reason, NextAuth.js uses snake case for a few fields. The @map attributes at least fix the database field names.
// Since these fields are only used by NextAuth.js internals, the Prisma field names have been left unchanged.

model Account {
  id                String    @id @default(cuid())
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  type              String
  provider          String
  providerAccountId String
  refresh_token     String?   @db.Text @map("refreshToken")
  access_token      String?   @db.Text @map("accessToken")
  expires_at        Int?      @map("expiresAt")
  token_type        String?   @map("tokenType")
  scope             String?
  id_token          String?   @db.Text @map("idToken")
  session_state     String?   @map("sessionState")

  userId            String
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  sessionToken  String    @unique
  expires       DateTime

  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model User {
  id              String          @id @default(cuid())
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  name            String?
  email           String?         @unique
  emailVerified   DateTime?
  image           String?

  accounts        Account[]
  sessions        Session[]
  surveys         Survey[]
  participations  Participation[]
}

model VerificationToken {
  id          String    @id @default(cuid())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  identifier  String
  token       String    @unique
  expires     DateTime

  @@unique([identifier, token])
}
